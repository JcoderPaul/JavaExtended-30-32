Пример работы с методом Files.walkFileTree() - который обходит
заданную директорию в глубину и получает данные о файлах и
вложенных папках.

Тут приведен пример как можно при помощи данного метода копировать
все файлы и каталоги внутри заданной директории.


******* Метод walkFileTree класса Files - Обход дерева файлов (каталогов) *******

Для решения задачи по обходу дерева каталогов (файлов) в Java существует
метод Files.walkFileTree(Path start, FileVisitor<? super Path> visitor),
который позволяет исследовать в глубину содержимое, заданной стартовой
папки Path start, при этом реализуя некие действия при достижении вложенного
объекта файла или папки (простой просмотр, копирование, удаление и т.д.)
за счет нашей собственной реализации методов интерфейса FileVisitor.

Метод имеет две реализации:
- * 1 * - public static Path walkFileTree(Path start,
                                       Set<FileVisitOption> options,
                                       int maxDepth,
                                       FileVisitor<? super Path> visitor) throws IOException

Параметры:
- start - стартовый файл (каталог);
- options - варианты настройки обхода;
- maxDepth - максимальное количество вложенных подкаталогов для посещения
- visitor - класс реализующий методы интерфейса FileVisitor - 'посетитель'
            вызывается для каждого файла (папки) при обходе.
Возвращает: Метод возвращает начальный файл (папку)
Ошибки при работе метода:
- IllegalArgumentException - если maxDepth параметр отрицательный;
- SecurityException - если менеджер безопасности запрещает доступ к стартовому файлу.
                      В случае поставщика по умолчанию checkRead метод вызывается для
                      проверки доступа на чтение к каталогу;
- IOException - если ошибка ввода/вывода вызвана методом FileVisitor.

Метод просматривает дерево файлов с корнем в заданном начальном файле
(папке) Path start. Обход дерева файлов осуществляется в глубину, при
этом реализации методов интерфейса FileVisitor вызывается для каждого
обнаруженного файла или папки. Обход дерева файлов завершается, когда
все доступные файлы (папки) в дереве были посещены или один из методов
FileVisitor возвращает результат TERMINATE.

Если метод посещения FileVisitor завершается из-за IOException,
не перехваченной ошибки или исключения времени выполнения, тогда обход
завершается, и ошибка или исключение распространяются на вызывающую
сторону этого метода.

Для каждого обнаруженного файла метод walkFileTree пытается прочитать
его атрибуты BasicFileAttributes. Если файл не является каталогом,
вызывается реализация метода *.visitFile() интерфейса FileVisitor с
атрибутами файла. Если атрибуты файла не могут быть прочитаны из-за
исключения ввода-вывода, то вызывается метод *.visitFileFailed(),
этого же интерфейса, с исключением ввода-вывода.

Если файл является каталогом, и каталог не может быть открыт, то
активируется метод *.visitFileFailed(), который вызывается с исключением
ввода-вывода, после чего обход дерева файлов продолжается по умолчанию
в следующем одноуровневом каталоге.

Если каталог успешно открыт, то посещаются записи в каталоге и их потомки.
Когда все записи были посещены или во время итерации каталога возникает
ошибка ввода-вывода, каталог закрывается и вызывается реализация метода
*.postVisitDirectory(). Затем обход файлового дерева по умолчанию продолжается
со следующего родственного каталога.

По умолчанию символические ссылки не следуют этому методу автоматически.
Если параметр 'options' содержит параметр 'FOLLOW_LINKS', выполняется переход
по символическим ссылкам. При переходе по ссылкам атрибуты цели не могут
быть прочитаны, тогда этот метод пытается получить BasicFileAttributes ссылки.
Если их можно прочитать, то вызывается метод *.visitFile() с атрибутами ссылки
(в противном случае вызывается метод *.visitFileFailed(), как указано выше).

Если параметр 'options' содержит параметр 'FOLLOW_LINKS', то метод *.walkFileTree()
отслеживает посещенные каталоги, чтобы можно было обнаружить циклы.

Цикл возникает, когда в каталоге есть запись, которая является предком каталога.
Обнаружение циклов выполняется путем записи файловых ключей каталогов или, если
файловые ключи недоступны, путем вызова метода *.isSameFile() для проверки того,
является ли каталог тем же файлом, что и предок.

При обнаружении цикла он обрабатывается как ошибка ввода-вывода, и вызывается метод
*.visitFileFailed() с экземпляром FileSystemLoopException.

Параметр 'maxDepth' — это максимальное количество уровней директорий для посещения.
Значение 0 означает, что посещается только начальный файл, если это не запрещено
администратором безопасности. Значение MAX_VALUE может использоваться для указания
того, что все уровни должны быть посещены.

Метод *.visitFile() интерфейса FileVisitor вызывается для всех файлов, включая каталоги,
обнаруженные в maxDepth, за исключением случаев, когда основные атрибуты файла не могут
быть прочитаны, и в этом случае вызывается метод *.visitFileFailed().

Если FileVisitor возвращает нулевой результат, генерируется исключение NullPointerException.

Когда менеджер безопасности установлен и запрещает доступ к файлу (или каталогу), он
игнорируется, и FileVisitor не вызывается для этого файла (или каталога).

- * 2 * - public static Path walkFileTree(Path start,
                                       FileVisitor<? super Path> visitor) throws IOException
Параметры:
- start - стартовый файл;
- visitor - класс реализующий интерфейс FileVisitor, методы которого вызываются для каждого
            файла (папки) при обходе;
Возвращает: начальный файл
Исключения:
- SecurityException - если менеджер безопасности запрещает доступ к стартовому файлу. В случае
                      поставщика по умолчанию checkRead метод вызывается для проверки доступа
                      на чтение к каталогу.
- IOException - если ошибка ввода/вывода вызвана методом посетителя.

Такой синтаксис эквивалентен работе метода со следующими параметрами:
----------------------------------------------------------------------------------------------
walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor);
----------------------------------------------------------------------------------------------
Т.е. он не переходит по символическим ссылкам, а посещает все уровни файлового дерева.

Более подробно про FileVisitor и Files.walkFileTree():
https://docs.oracle.com/javase/tutorial/essential/io/walk.html
https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html

