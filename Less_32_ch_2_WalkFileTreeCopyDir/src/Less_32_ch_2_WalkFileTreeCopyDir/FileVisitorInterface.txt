******* The FileVisitor Interface - Интерфейс файловый визитер *******

Чтобы пройтись по дереву файлов, с использованием метода Files.walkFileTree()
нам сначала нужно реализовать методы интерфейса FileVisitor. Каждый из которых
определяет требуемое поведение в ключевых точках процесса обхода:
- при посещении файла;
- перед доступом к каталогу;
- после доступа к каталогу или при возникновении сбоя.
В интерфейсе есть четыре метода, соответствующие этим ситуациям:
- preVisitDirectory - вызывается перед посещением записей каталога
                      (перед входом в папку);
- postVisitDirectory - вызывается после посещения всех записей в каталоге.
                       Если возникают какие-либо ошибки, в метод передается
                       конкретное исключение;
- visitFile - вызывается для посещаемого файла. В метод передаются атрибуты
              BasicFileAttributes файла, или мы можем использовать пакет
              атрибутов файла для чтения определенного набора атрибутов.

Например, мы можем прочитать DosFileAttributeView файла, чтобы определить,
установлен ли в файле «скрытый» бит.

- visitFileFailed - вызывается, когда файл недоступен. Конкретное исключение
                    передается методу. Мы можем выбрать, генерировать ли исключение,
                    выводить его на консоль или в файл журнала и т.д.

Если нам не нужно реализовывать все четыре метода FileVisitor, вместо реализации
интерфейса FileVisitor мы можем расширить класс SimpleFileVisitor. Этот класс,
реализующий интерфейс FileVisitor, просматривает все файлы в дереве и выдает
IOError при обнаружении ошибки.

Мы можем расширить этот класс и переопределить только те методы, которые нам нужны.

Пример, который расширяет SimpleFileVisitor для печати всех записей в дереве
файлов. Он печатает запись независимо от того, является ли запись обычным файлом,
символической ссылкой, каталогом или каким-либо другим «неуказанным» типом файла.
Он также печатает размер в байтах каждого файла.
Любое обнаруженное исключение выводится на консоль.
См. класс: MyClasses\OraclePrintFilesEx
См. работу класса: Less_32_WalkFileTree_Step2

******* Запуск процесса обхода дерева каталогов *******

После того, как мы реализовали свой файл FileVisitor мы можем запустить обход через
Files.walkFileTree
Вариантов реализации метода два:
- walkFileTree(Path, FileVisitor)
- walkFileTree(Path, Set<FileVisitOption>, int, FileVisitor)
Для первого метода требуется только начальная точка и экземпляр вашего FileVisitor.
Мы можем вызвать OraclePrintFilesEx (приведенный в примере) посетителя файла
следующим образом:
-----------------------------------------------------------------------------------
Path startingDir = ...;
OraclePrintFilesEx orc_pf_e = new OraclePrintFilesEx();
Files.walkFileTree(startingDir, orc_pf_e);
-----------------------------------------------------------------------------------

Второй вариант вызова walkFileTree позволяет дополнительно указать ограничение на
количество посещаемых уровней и набор FileVisitOption перечислений. Если мы хотим,
чтобы этот метод обходил все дерево файлов, мы должны указать Integer.MAX_VALUE
аргумент максимальной глубины (более подробно описано в ReadMe.txt).

Мы можем указать FileVisitOption перечисление, FOLLOW_LINKS которое указывает,
что следует использовать символические ссылки.

Этот фрагмент кода показывает, как можно вызвать метод с четырьмя аргументами:
-----------------------------------------------------------------------------------
import static java.nio.file.FileVisitResult.*;

Path startingDir = ...;

EnumSet<FileVisitOption> opts = EnumSet.of(FOLLOW_LINKS);

Finder finder = new Finder(pattern);
Files.walkFileTree(startingDir, opts, Integer.MAX_VALUE, finder);
-----------------------------------------------------------------------------------

******* Соображения при создании FileVisitor *******

Дерево файлов сначала просматривается в глубину, но мы не можем делать никаких предположений
о порядке итераций, в котором посещаются подкаталоги. Если наша программа будет изменять
файловую систему, нам необходимо тщательно продумать, как мы реализуем свой файл класс
подписанный на FileVisitor.

Например, если мы пишем рекурсивное удаление, мы сначала удаляете файлы в каталоге, прежде
чем удалять сам каталог. В этом случае мы реализуем удаление каталога в методе
*.postVisitDirectory().

Если мы пишем рекурсивное копирование, мы создаем новый каталог в методе *.preVisitDirectory()
перед попыткой скопировать в него файлы (в visitFiles). Если мы хотим сохранить атрибуты исходного
каталога (аналогично команде UNIX cp -p), нам нужно сделать это после копирования файлов в
формате postVisitDirectory. В примере 'OracleExampleCopy' показано, как это сделать.

Если мы реализуем поиск файлов, мы выполняем сравнение в *.visitFile() методе. Этот метод находит
все файлы, соответствующие нашим критериям, но не находит каталоги. Если мы хотите найти и
файлы, и каталоги, мы должны выполнить сравнение с помощью метода *.preVisitDirectory() или
*.postVisitDirectory(). В примере OracleExampleFind показано, как это сделать.

Нам нужно решить, хотим ли мы использовать символические ссылки. Например, если мы удаляем файлы,
переход по символическим ссылкам может оказаться нецелесообразным. Если мы копируем файловое дерево,
мы можем разрешить это. По умолчанию *.walkFileTree() не переходит по символическим ссылкам.

Метод visitFile вызывается для файлов. Если мы укажем FOLLOW_LINKS параметр и нише файловое дерево
имеет циклическую ссылку на родительский каталог, зацикленный каталог обрабатывается в методе
visitFileFailed с расширением FileSystemLoopException.

В следующем фрагменте кода показано, как поймать циклическую ссылку, и он взят из примера с копированием:
----------------------------------------------------------------------------------------------------------
@Override
public FileVisitResult
    visitFileFailed(Path file,
        IOException exc) {
    if (exc instanceof FileSystemLoopException) {
        System.err.println("cycle detected: " + file);
    } else {
        System.err.format("Unable to copy:" + " %s: %s%n", file, exc);
    }
    return CONTINUE;
}
----------------------------------------------------------------------------------------------------------
Такое может произойти только тогда, когда программа переходит по символическим ссылкам.

******* Управление методами работы интерфейса FileVisitor *******

Возможно, мы хотим пройтись по дереву файлов в поисках определенного каталога и, когда он
будет найден, мы хотим, чтобы процесс завершился. Возможно, мы захотим пропустить определенные каталоги.

Методы FileVisitor возвращают FileVisitResult значение. Мы можем прервать процесс обхода файла или
контролировать, посещается ли каталог с определенными значениями, которые мы возвращаем в методах
FileVisitor:
- CONTINUE - указывает, что обход файла должен продолжаться, если метод *.preVisitDirectory()
             возвращает CONTINUE, каталог посещается.
- TERMINATE - немедленно прерывает просмотр файла (папки), после возврата этого значения
              никакие другие методы обхода файлов не вызываются.
- SKIP_SUBTREE - при возврате методом *.preVisitDirectory() этого значения указанный каталог
                 и его подкаталоги пропускаются. Эта ветвь «вырезается» из дерева.
                 Т.е. в эту директорию заходить не надо (полный игнор).
- SKIP_SIBLINGS - когда метод *.preVisitDirectory() возвращает это значение, указанный каталог
                  не посещается, *.postVisitDirectory() не вызывается и никакие другие непосещенные
                  одноуровневые каталоги не посещаются. При возвращении методом *.postVisitDirectory()
                  этого значения, все вложения в текущем каталоге не посещаются. По сути, в
                  указанном каталоге больше ничего не происходит (но, он не вырезается из дерева).

В этом фрагменте кода любой указанный каталог 'SCCS' пропускается:
----------------------------------------------------------------------------------------------------------
import static java.nio.file.FileVisitResult.*;

public FileVisitResult
     preVisitDirectory(Path dir,
         BasicFileAttributes attrs) {
    (if (dir.getFileName().toString().equals("SCCS")) {
         return SKIP_SUBTREE;
    }
    return CONTINUE;
}
----------------------------------------------------------------------------------------------------------
В этом фрагменте кода, как только конкретный файл находится, имя файла выводится на стандартный вывод,
и обход файла прекращается:
----------------------------------------------------------------------------------------------------------
import static java.nio.file.FileVisitResult.*;

// The file we are looking for.
Path lookingFor = ...;

public FileVisitResult
    visitFile(Path file,
        BasicFileAttributes attr) {
    if (file.getFileName().equals(lookingFor)) {
        System.out.println("Located file: " + file);
        return TERMINATE;
    }
    return CONTINUE;
}
----------------------------------------------------------------------------------------------------------

Более подробно про FileVisitor и Files.walkFileTree():
https://docs.oracle.com/javase/tutorial/essential/io/walk.html
https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html